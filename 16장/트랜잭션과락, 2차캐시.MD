# 16장 트랜잭션과 락, 2차 캐시
## 트랜잭션

**ACID**

- `원자성`: 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공 혹은 모두 실패해야 한다. (feat. 가장 작은 작업 단위)
  

- `일관성`: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 데이터베이스에서 정한 무결성 제약 조건을 만족해야한다.
  

- `격리성`: 동시에 실행되는 트랜잭션이 서로에게 영향을 미치지 않도록 격리되어야 한다. (동시에 같은 데이터를 수정할 수 없다.).
  동시성과 관련된 성능 이슈가 있으므로 레벨은 선택할 수 있다.


- `지속성`: 트랜잭션이 끝나면 그 결과가 항상 기록되어야 한다. 시스템에 문제가 발생해도 로그등을 통해 성공한 트랜잭션 내용을 복구할 수 있어야 한다.


**격리 레벨**

동시성으로 인해 발생할 수 있는 문제
- `DIRTY READ`: 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상


- `NON-REPEATABLE READ`: 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리가 상이하게 나타나는 현상.


- `PHANTOM READ`: 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상


격리 수준 별 발생 가능한 문제

- READ UNCOMMITTED: <br>
  `DIRTY READ`, `NON-REPEATABLE READ`, `PHANTOM READ`<br>
  > T1, T2 가 동시에 실행 중일 떄 T2 의 변경 내용이 commit 을 하지 않아도 T1 에서 작업한 내용이 조회되는 현상 
  
- READ COMMITTED: <br>
  `NON-REPEATABLE READ`, `PHANTOM READ`
  > T1 이 id: id < 10 까지의 행을 조회하고 작업을 처리하는 중 T2 가 동일한 id 행의 내용을 업데이트 하고 
  > commit 을 했을 경우 T1 은 동일한 트랜잭션일지라도 id < 10 을 조회할 때 T2 의 작업 내용이 반영된 내용을 조회하게 된다.
  > 동일한 트랜잭션 일지라도 처음 조회할 때와 다른 결과를 조회하게 됨

- REPEATABLE READ: <br>
  `PHANTOM READ`
  > NON-REPEATABLE READ 의 상황은 발생하지 않지만 T2 에서 id: 5 의 행을 등록 하는 경우 T1 에서 id: 5 의 행까지 추가로 등록된다.
- SERIALIZABLE: <br>
  없음
  > 문제가 발생하지는 않지만 높은 격리레벨로 인해 성능상의 이슈가 발생한다.

## 낙관적 락 / 비관적 락 기초
**낙관적 락**

트랜잭션 대부분은 충돌이 발생하지 않는다고 가정하는 방법. 동시 처리가 발생하는 데이터가 거의 없을 것이라 예상하는 경우.<br>
1000 건 중 중복 처리 건수가 2 건이라면 0.2% 이므로 0.2% 정도는 오류 핸들링을 통해 처리해도 크게 문제가 없을 것 
<br><br>

**비관적 락**

대부분의 트랜잭션이 충동이 발생할 것으로 가정해서 우선 락을 걸고 보는 방법. <br>
100 건 중 중복 처리 건수가 99 건이라면 99% 인데 낙관적 락을 걸게 되면 대부분의 처리가 실패할 것이므로 무조건 락을 걸고 보는 방식 
<br><br>

**@Version**
```kotlin
@Entity
class Board(
  @Id
  val id: Long,
  val title: String,
  @Version
  val version: Int,
)
```
위의 예제와 같이 @Version 을 붙여주면 조회 시점과 수정 시점의 버전이 다를 경우 예외가 발생한다.<br>
T1 에서 조회한 엔티티를 수정하고 있는데 T2 에서 동일한 버전의 엔티티를 수정해서 커밋을 해버리면 버전이 증가되어
T1 이 커밋을 할 때 오류가 발생하게 된다.(T1 엔티티의 상태는 버전 1 / 버전은 2로 증가)
이렇게 버전정보를 사용하면 `최초의 커밋만 인정`하기가 가능하다.

@Version 을 사용하면 엔티티의 값을 변경할때 버전 값이 증가하게 된다.


> **두번의 갱신 분실 문제 (second lost updated problem)**
> 예를 들면 사용자 A, B 가 거의 동시에 수정 버튼을 클릭하고 애플리케이션에 의해 db 업데이트가 일어난다고 할때
> A 가 먼저 처리되고 B 가 연달아 처리가 되어버리면 A 의 입장에서는 의도와 다른 수정으로 인식할 수 있다.
> 해결방법은 다음 3가지가 있다.
> 1. 마지막 커밋만 인정하기
> 2. 최초 커밋만 인정하기
> 3. 충돌하는 갱신 내용 병합하기
> 일반적으로는 마지막 커밋만 인정되도록 개발이 이루어질텐데 상황에 따라 최초 커밋만 인정하는 것이 합리적일 수 있다.<br>
> 예) 물건을 주문하는 애플리케이션의 경우 선착순으로 이루어지는 것이 올바르므로 최초 커밋을 인정하고 이후 처리는 오류로 던지는게
> 합리적이다.

## JPA 낙관적 락
Entity Manager 를 직접 사용하는 방법이 기술되어 있는데 우리는 Spring 을 사용하므로 Spring 에서 사용하는 방법을 알아보자.
```kotlin
// EntityManager 사용
val board = em.find(Board.class, id, LockModeType.OPTIMISTIC)
// 필요할 때 걸기
val board = em.find(Board.class, id)
em.lock(LockModeType.OPTIMISTIC)
```

```kotlin
// Annotation 사용
interface BoardRepository: JpaRepository<Board, Int> {
  @Lock(LockModeType.OPTIMISTIC)
  fun findByTitle(title: String)
}
```
낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다는 특징이 있다.
(Application Level 의 락 관리이므로)


**락모드**

`NONE`:<br>
락 옵션을 적용하지 않아도 엔티티에 @Version 이 적용된 필드만 있으면 낙관적 락이 적용된다.

`OPTIMISTIC`:<br>
@Version 만 적용했을 경우 엔티티를 수정해야 버전을 체크하지만 이 옵션을 추가하면 에티티를 조회만 해도 버전을 체크한다.
즉, 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다.
T1 이 엔티티를 조회할 때 v.1 이 되고 트랜잭션이 종료되지 않은 상태에서 T2 가 동일한 엔티티를 조회하면 v.2 가 된다.
T1 은 v.1 을 소유하고 있으므로 다시 조회 한 후 커밋을 시도하면 오류를 발생시킨다. 

`OPTIMISTIC_FORCE_INCREMENT`:<br>
낙관적 락을 사용하면서 버전 정보를 강제로 증가시킨다.

`READ`:<br>
it’s a synonym for OPTIMISTIC (JPA 1.0 호환 기능)

`WRITE`:<br>
it’s a synonym for OPTIMISTIC_FORCE_INCREMENT (JPA 1.0 호환 기능)

`PESSIMISTIC_READ`:<br>
Shared Lock 을 얻고 데이터가 업데이트되거나 삭제되지 않도록 한다.


`PESSIMISTIC_WRITE`:<br>
Exclusive Lock 을 획득하고 데이터를 읽거나, 업데이트하거나, 삭제하는 것을 방지한다.


`PESSIMISTIC_FORCE_INCREMENT`:<br>
PESSIMISTIC_WRITE 와 유사하게 작동하며 엔티티의 버전 속성을 추가로 증가시킨다.

### OPTIMISTIC_FORCE_INCREMENT
`Aggregate Root` 에 사용 가능하다.

https://eocoding.tistory.com/36

엔티티를 수정하지 않아도 트랜잭션을 커밋하면 버전이 증가한다. 연관관계가 다양한 엔티티의 경우 연관관계가 있는 엔티티가 수정이 되어도
해당 엔티티의 버전이 증가하는 방식으로 논리적 단위의 엔티티 묶음 버전 정보를 관리한다.<br>
트랜잭션 종료 시 +1, 만약 정보의 수정까지 일어나면 +1 두번의 증가가 있을 수 있다.<br>
(만약 연관관계가 있는 엔티티의 정보만 수정할 경우에 Aggregate Root 의 버전은 +1, 연관관계 엔티티는 +2 가 되는 경우는?)

### JPA 비관적 락
비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존한다.
- 엔티티가 아닌 스칼라 타입을 조회할 때도 사용가능 하다.
- 데이터를 수정하는 즉시 트랜잭션 충돌을 감지한다.


## 2차 캐시
### 1차 캐시와 2차 캐시
영속성 컨텍스트 = 1차 캐시:<br>
트랜잭션이 끝나면 사라지는 캐시

애플리케이션 범위의 캐시 = 2차 캐시:<br>
애플리케이션이 종료되면 사라지는 캐시. (분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지된다.)
캐시 구현체는 `JCache`, `Ehcache` 등을 사용한다.
<br><br>

> **`EHCache`**
> - EHCache는 오픈 소스 기반의 Local Cache이다.<br>
> - 속도가 빠르며 경량 Cache라는 장점이 있다.<br>
> - Disk, Memory 저장이 가능한 형태<br>
> - 서버 간 분산 캐시를 지원한다 (동기/비동기 복제)<br>

2차 캐시는 다음과 같은 메커니즘을 따른다.
- 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회한다.
- 2차 캐시에 엔티티가 없으면 데이터베이스를 조회해서 결과를 2차 캐시에 보관한다.
- 2차 캐시에 저장되어 있는 엔티티를 조회하면 `복사본`을 만들어 반환한다.

##### 2차 캐시 특징
- 영속성 컨텍스트가 다를 경우 객체의 동일성을 보장하지 않는다. (= transaction 이 다를 경우 동일하지 않다)
- 2차 캐시는 조회한 객체를 복사본을 만들어 조회한다. 
  캐시한 객체 그대로 반환하면 여러 곳에서 같은 객체를 동시에 수정하는 문제가 발생할 수 있다.

### 2차 캐시 사용
##### 캐시모드

`ALL`: 모든 엔티티를 캐시<br>
`NONE`: 캐시를 사용하지 않음<br>
`ENABLE_SELECTIVE`: Cacheable(true) 로 설정된 엔티티만 캐시를 적용<br>
`DISABLE_SELECTIVE`: 모든 엔티티를 캐시하는데 Cacheable(false) 만 캐시 제외<br>
`UNSPECIFIED`: JPA 구현체가 정의한 설정을 따른다.<br><br>


##### 캐시보관모드
`USE`: 조회한 데이터를 캐시에 저장하고 조회한 데이터가 캐시에 있을 경우 최산으로 갱신하지 않는다.<br>
트랜잭션을 커밋하면 등록 수정한 엔티티도 캐시에 저장한다.
`BYPASS`: 캐시에 저장하지 않는다.<br>
`REFRESH`: USE 전략에 추가로 데이터베이스에서 조회한 엔티티를 최신 상태로 다시 캐시한다.<br><br>


##### 쿼리캐시
쿼리 캐시는 캐시한 데이터 집합을 최신 데이터로 유지해야 하기 때문에 쿼리 캐시를 실행한 시간과 쿼리 캐시 대상 테이블들의 최근 변경 시간을 비교한다.<br>
쿼리를 실행하면 `StandardQueryCache` 캐시 영역에서 타임스탬프를 조회하고 각 테이블들의 타임스탬프가 최신이면 리프래시한다.


쿼리캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시한다.(JPA 표준이 아님) 따라서 캐싱이 되었다고 해도 2차 캐시영역에 해당하는 엔티티가 캐시 되어 있지 않으면
쿼리가 실행될 수 있다. 쿼리캐시와 컬렉션 캐시를 사용하는 대상 엔티티는 반드시 엔티티 캐시를 사용해야한다.
